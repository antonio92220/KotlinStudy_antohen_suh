package org.example.lesson_10

fun main() {
    // 1. Вызываем блок А и сохраняем результат в переменную
    val dataFromA = blockA()

    // 2. Вызываем блок Б, ПЕРЕДАВАЯ ему данные от А
    val dataFromB = blockB(dataFromA)

    // 3. Вызываем блок В, ПЕРЕДАВАЯ ему данные от Б
    blockC(dataFromB)
}

// Блок А: Просто отдает список. (Тут у тебя было все верно)
fun blockA(): List<String> {
    return listOf("192.168.1.1", "10.0.0.5", "172.16.0.2")
}

// Блок Б: ПРИНИМАЕТ список (inputList) и возвращает новый
fun blockB(inputList: List<String>): List<String> {
    val resultList = mutableListOf<String>()

    // Мы работаем с тем списком, который нам передали (inputList)
    inputList.forEach {
        if (it.startsWith("192.")) {
            resultList.add(it)
        }
    }

    return resultList
}

// Блок В: ПРИНИМАЕТ список (finalList) и ничего не возвращает (просто печатает)
fun blockC(finalList: List<String>) {
    for (ip in finalList) {
        println(ip) // ip - это уже строка, не нужно писать list[ip]
    }
}

/*Задача 5: Цепочка обработки данных (Сложная)
Создай три отдельных, независимых блока кода и свяжи их в единый процесс:

Блок А (Исходные данные): Не принимает параметров. Должен вернуть список из трех
IP-адресов в формате строк (например, "192.168.1.1", "10.0.0.5", "172.16.0.2").

Блок Б (Обработка): Принимает список IP-адресов от Блока А. Должен проверить каждый адрес и вернуть
только те, которые начинаются с "192.".

Блок В (Финальный вывод): Принимает отфильтрованный список от Блока Б. Должен вывести каждый адрес из этого списка на отдельной строке.

Вызови Блок А в main, передай его результат в Блок Б, а результат Блока Б — в Блок В.*/
